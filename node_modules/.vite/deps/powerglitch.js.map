{
  "version": 3,
  "sources": ["../../powerglitch/lib/src/index.js"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PowerGlitch = exports.mergeOptions = void 0;\n/**\n * Get best-looking default options for most elements for a given playMode.\n */\nconst getDefaultOptions = (playMode = 'always') => {\n    return {\n        playMode,\n        createContainers: true,\n        hideOverflow: false,\n        timing: playMode === 'always' ? { duration: 2 * 1000, iterations: Infinity } : { duration: 250, iterations: 1 },\n        glitchTimeSpan: playMode === 'always' ? { start: 0.5, end: 0.7 } : { start: 0, end: 1, },\n        shake: {\n            velocity: 15,\n            amplitudeX: 0.2,\n            amplitudeY: 0.2,\n        },\n        slice: playMode === 'click' ? {\n            count: 15,\n            velocity: 20,\n            minHeight: 0.02,\n            maxHeight: 0.15,\n            hueRotate: true,\n        } : {\n            count: 6,\n            velocity: 15,\n            minHeight: 0.02,\n            maxHeight: 0.15,\n            hueRotate: true,\n        },\n        pulse: false,\n    };\n};\n/**\n * Glitch factor function, returns a value between 0 and 1 telling how much the animation should glitch at a given stepPct.\n */\nconst getGlitchFactor = (options, stepPct) => {\n    if (!options.glitchTimeSpan) {\n        return 1;\n    }\n    const glitchStart = options.glitchTimeSpan.start;\n    const glitchEnd = options.glitchTimeSpan.end;\n    if (stepPct < glitchStart || stepPct > glitchEnd) {\n        return 0;\n    }\n    const glitchPeak = glitchStart + (glitchEnd - glitchStart) / 2;\n    if (stepPct < glitchPeak) {\n        return (stepPct - glitchStart) / (glitchPeak - glitchStart);\n    }\n    else {\n        return (glitchEnd - stepPct) / (glitchEnd - glitchPeak);\n    }\n};\n/**\n * Get a random value between -1 and 1, which biases towards the center if the animation should not glitch at the given `stepPct` moment.\n */\nconst getGlitchRandom = (options, stepPct) => {\n    return (Math.random() - .5) * 2 * getGlitchFactor(options, stepPct);\n};\n/**\n * Get a random rectangle values in % to glitch. Percent values are between 0 and 100. Returns the rectangle as a CSS polygon.\n * @param minHeight Minimum height of the rectangle in percent, between 0 and 1.\n * @param maxHeight Maximum height of the rectangle in percent, between 0 and 1.\n * @param minWidth Minimum width of the rectangle in percent, between 0 and 1.\n * @param maxWidth Maximum width of the rectangle in percent, between 0 and 1.\n */\nconst getRandomRectanglePolygonCss = ({ minHeight, maxHeight, minWidth, maxWidth }) => {\n    const height = Math.floor(Math.random() * ((maxHeight - minHeight) * 100 + 1)) + minHeight * 100;\n    const width = Math.floor(Math.random() * ((maxWidth - minWidth) * 100 + 1)) + minWidth * 100;\n    // Put this rectangle somewhere in the container so that it does not go out of the screen.\n    const top = Math.floor(Math.random() * (100 - height));\n    const left = Math.floor(Math.random() * (100 - width));\n    const topRight = `${left + width}% ${top}%`;\n    const bottomRight = `${left + width}% ${top + height}%`;\n    const bottomLeft = `${left}% ${top + height}%`;\n    const topLeft = `${left}% ${top}%`;\n    return `polygon(${topRight},${bottomRight},${bottomLeft},${topLeft})`;\n};\n/**\n * Generate a slice layer, slicing part of the element and moving it somwhere else.\n * @param options\n */\nconst generateGlitchSliceLayer = (options) => {\n    const stepCount = Math.floor(options.slice.velocity * options.timing.duration / 1000) + 1;\n    const steps = [];\n    for (let index = 0; index < stepCount; ++index) {\n        if (getGlitchFactor(options, index / stepCount) === 0) {\n            steps.push({\n                opacity: '0',\n                transform: 'none',\n                clipPath: 'unset',\n            });\n            continue;\n        }\n        const translateX = getGlitchRandom(options, index / stepCount) * 30;\n        const styles = {\n            opacity: '1',\n            transform: `translate3d(${translateX}%,0,0)`,\n            clipPath: getRandomRectanglePolygonCss({ minHeight: options.slice.minHeight, maxHeight: options.slice.maxHeight, minWidth: 1, maxWidth: 1 }),\n        };\n        if (options.slice.hueRotate) {\n            styles.filter = `hue-rotate(${Math.floor(getGlitchRandom(options, index / stepCount) * 360)}deg)`;\n        }\n        steps.push(styles);\n    }\n    return {\n        steps,\n        timing: Object.assign({ easing: `steps(${stepCount},jump-start)` }, options.timing),\n    };\n};\n/**\n * Generate a pulse layer, a single transparent and growing layer.\n * @param options\n */\nconst generateGlitchPulseLayer = (options) => {\n    return !options.pulse ? null : {\n        steps: [\n            { transform: 'scale(1)', opacity: '1', },\n            { transform: `scale(${options.pulse.scale})`, opacity: '0', },\n        ],\n        timing: Object.assign(Object.assign({}, options.timing), { delay: (options.glitchTimeSpan ? options.glitchTimeSpan.start : 0) * options.timing.duration, easing: 'ease-in-out' }),\n    };\n};\n/**\n * Generate the base layer, which may or may not shake depending on the options.\n * @param options\n */\nconst generateBaseLayer = (options) => {\n    if (!options.shake) {\n        return { steps: [], timing: {} };\n    }\n    const stepCount = Math.floor(options.shake.velocity * options.timing.duration / 1000) + 1;\n    const steps = [];\n    for (let index = 0; index < stepCount; ++index) {\n        const translateX = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeX * 100;\n        const translateY = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeY * 100;\n        steps.push({\n            transform: `translate3d(${translateX}%,${translateY}%,0)`,\n        });\n    }\n    return {\n        steps,\n        timing: Object.assign({ easing: `steps(${stepCount},jump-start)` }, options.timing),\n    };\n};\n/**\n * Generate the layers that deterministically define a glitch animation for the specified options.\n */\nconst generateLayers = (options) => [\n    generateBaseLayer(options),\n    generateGlitchPulseLayer(options),\n    ...Array.from({ length: options.slice.count }).map(() => generateGlitchSliceLayer(options)),\n].filter(entry => entry !== null);\n/**\n* Performs a deep merge of option objects and returns new object. Does not modify\n* objects (immutable) and will ignore arrays.\n* @param objects - Objects to merge\n* @returns New object with merged key/values\n*/\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst mergeOptions = (...objects) => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const isObject = (obj) => obj && typeof obj === 'object';\n    return objects.reduce((prev, obj) => {\n        Object.keys(obj)\n            .forEach(key => {\n            if (isObject(prev[key]) && isObject(obj[key])) {\n                prev[key] = (0, exports.mergeOptions)(prev[key], obj[key]);\n            }\n            else if (obj[key] !== undefined) {\n                prev[key] = obj[key];\n            }\n        });\n        return prev;\n    }, {});\n};\nexports.mergeOptions = mergeOptions;\n/**\n * Prepare the DOM to set up the glitch effect.\n * @remarks\n * Depending on the element state:\n *  - Whether it was glitched before or not,\n *  - Whether current element display attributes\n *  - Whether options.createContainers is true/false\n * The top-level container and layer containers might be different objects and might need to be created.\n * @param element\n * @param options\n * @returns\n */\nconst prepareGlitchElement = (element, options) => {\n    var _a, _b;\n    // If not creating the containers\n    if (!options.createContainers) {\n        return {\n            container: element,\n            layersContainer: element,\n            glitched: element.firstElementChild,\n        };\n    }\n    // If first glitch\n    if (!element.dataset.glitched) {\n        // Setup the layer container using grid to stack elements\n        const layersContainer = document.createElement('div');\n        // If current element is an inline element\n        const container = document.createElement('div');\n        if (getComputedStyle(element).getPropertyValue('display').match(/^inline/)) {\n            container.style.display = 'inline-block';\n        }\n        // Add the layers container to the global container\n        container.appendChild(layersContainer);\n        // Replace element with the new container\n        (_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(container, element);\n        layersContainer.prepend(element);\n        return {\n            container,\n            layersContainer,\n            glitched: element,\n        };\n    }\n    // Not first glitch, with createContainers=true\n    const layersContainer = element.parentElement;\n    const container = (_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.parentElement;\n    // Remove all glitch layers but keep the first one (which is the original element)\n    while (layersContainer.children.length > 1) {\n        layersContainer.removeChild(layersContainer.children[1]);\n    }\n    // Cancel the animation on the first layer\n    layersContainer.firstElementChild.getAnimations().forEach(animation => animation.cancel());\n    return {\n        container,\n        layersContainer,\n        glitched: element,\n    };\n};\n/**\n * Given a set of computed layers and user options, glitch a given element\n * @param element\n * @param layers\n * @param options\n */\nconst glitchElement = (element, layers, options) => {\n    const { glitched, container, layersContainer } = prepareGlitchElement(element, options);\n    // Force grid display on the layer container\n    layersContainer.style.display = 'grid';\n    // Overflow\n    if (options.hideOverflow) {\n        container.style.overflow = 'hidden';\n    }\n    // If setting HTML manually\n    if (options.html) {\n        glitched.innerHTML = options.html;\n    }\n    // Stack original element too (it is used as the base shaking layer)\n    glitched.style.gridArea = '1/1/-1/-1';\n    // Base layer\n    const baseLayer = glitched.cloneNode(true);\n    // Stack this layer\n    baseLayer.style.gridArea = '1/1/-1/-1';\n    baseLayer.style.userSelect = 'none';\n    baseLayer.style.pointerEvents = 'none';\n    baseLayer.style.opacity = '0';\n    for (let i = 0; i < layers.length - 1; ++i) {\n        const layerDiv = baseLayer.cloneNode(true);\n        layersContainer.appendChild(layerDiv);\n    }\n    // Glitch control functions\n    const startGlitch = () => {\n        layers.forEach((layer, i) => {\n            layersContainer\n                .children[i]\n                .animate(layer.steps, layer.timing);\n        });\n    };\n    const stopGlitch = () => {\n        layers.forEach((_, i) => {\n            layersContainer\n                .children[i]\n                .getAnimations()\n                .forEach(animation => {\n                animation.cancel();\n            });\n        });\n    };\n    // Depending on the selected play mode, orchestrate when to start/stop the glitch\n    container.onmouseenter = null;\n    container.onmouseleave = null;\n    container.onclick = null;\n    switch (options.playMode) {\n        case 'always':\n            startGlitch();\n            break;\n        case 'hover':\n            container.onmouseenter = startGlitch;\n            container.onmouseleave = stopGlitch;\n            break;\n        case 'click':\n            container.onclick = () => { stopGlitch(); startGlitch(); };\n            break;\n    }\n    // Mark the glitched element as glitched for next round\n    element.dataset.glitched = '1';\n    return { container, startGlitch, stopGlitch };\n};\n/**\n * Make a single element glitch.\n * @param elOrSelector What to glitch. Can be a query selector, a list of HTMLElement, an HTMLElement or a NodeList.\n * @param userOptions Optional glitch customization options.\n */\nconst glitch = (elOrSelector = '.powerglitch', userOptions = {}) => {\n    // Fix options with defaults\n    const options = (0, exports.mergeOptions)(getDefaultOptions(userOptions.playMode), userOptions);\n    // Find elements to glitch\n    let elements = [];\n    if (typeof elOrSelector === 'string') {\n        elements = Array.from(document.querySelectorAll(elOrSelector));\n    }\n    else if (elOrSelector instanceof NodeList) {\n        elements = Array.from(elOrSelector);\n    }\n    else if (Array.isArray(elOrSelector)) {\n        elements = elOrSelector;\n    }\n    else if (elOrSelector instanceof HTMLElement) {\n        elements = [elOrSelector];\n    }\n    // Generate all animation layers\n    const layers = generateLayers(options);\n    // Animate each div element\n    const entries = elements.map(element => glitchElement(element, layers, options));\n    // Return list of containers and glitch control functions\n    return {\n        containers: entries.map(entry => entry.container),\n        startGlitch: () => entries.forEach(entry => entry.startGlitch()),\n        stopGlitch: () => entries.forEach(entry => entry.stopGlitch()),\n    };\n};\nexports.PowerGlitch = {\n    glitch,\n    generateLayers,\n    getDefaultOptions,\n};\n"],
  "mappings": "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",
  "names": ["layersContainer", "container"]
}

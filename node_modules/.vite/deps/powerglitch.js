import {
  __commonJS
} from "./chunk-AC2VUBZ6.js";

// node_modules/powerglitch/lib/src/index.js
var require_src = __commonJS({
  "node_modules/powerglitch/lib/src/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PowerGlitch = exports.mergeOptions = void 0;
    var getDefaultOptions = (playMode = "always") => {
      return {
        playMode,
        createContainers: true,
        hideOverflow: false,
        timing: playMode === "always" ? { duration: 2 * 1e3, iterations: Infinity } : { duration: 250, iterations: 1 },
        glitchTimeSpan: playMode === "always" ? { start: 0.5, end: 0.7 } : { start: 0, end: 1 },
        shake: {
          velocity: 15,
          amplitudeX: 0.2,
          amplitudeY: 0.2
        },
        slice: playMode === "click" ? {
          count: 15,
          velocity: 20,
          minHeight: 0.02,
          maxHeight: 0.15,
          hueRotate: true
        } : {
          count: 6,
          velocity: 15,
          minHeight: 0.02,
          maxHeight: 0.15,
          hueRotate: true
        },
        pulse: false
      };
    };
    var getGlitchFactor = (options, stepPct) => {
      if (!options.glitchTimeSpan) {
        return 1;
      }
      const glitchStart = options.glitchTimeSpan.start;
      const glitchEnd = options.glitchTimeSpan.end;
      if (stepPct < glitchStart || stepPct > glitchEnd) {
        return 0;
      }
      const glitchPeak = glitchStart + (glitchEnd - glitchStart) / 2;
      if (stepPct < glitchPeak) {
        return (stepPct - glitchStart) / (glitchPeak - glitchStart);
      } else {
        return (glitchEnd - stepPct) / (glitchEnd - glitchPeak);
      }
    };
    var getGlitchRandom = (options, stepPct) => {
      return (Math.random() - 0.5) * 2 * getGlitchFactor(options, stepPct);
    };
    var getRandomRectanglePolygonCss = ({ minHeight, maxHeight, minWidth, maxWidth }) => {
      const height = Math.floor(Math.random() * ((maxHeight - minHeight) * 100 + 1)) + minHeight * 100;
      const width = Math.floor(Math.random() * ((maxWidth - minWidth) * 100 + 1)) + minWidth * 100;
      const top = Math.floor(Math.random() * (100 - height));
      const left = Math.floor(Math.random() * (100 - width));
      const topRight = `${left + width}% ${top}%`;
      const bottomRight = `${left + width}% ${top + height}%`;
      const bottomLeft = `${left}% ${top + height}%`;
      const topLeft = `${left}% ${top}%`;
      return `polygon(${topRight},${bottomRight},${bottomLeft},${topLeft})`;
    };
    var generateGlitchSliceLayer = (options) => {
      const stepCount = Math.floor(options.slice.velocity * options.timing.duration / 1e3) + 1;
      const steps = [];
      for (let index = 0; index < stepCount; ++index) {
        if (getGlitchFactor(options, index / stepCount) === 0) {
          steps.push({
            opacity: "0",
            transform: "none",
            clipPath: "unset"
          });
          continue;
        }
        const translateX = getGlitchRandom(options, index / stepCount) * 30;
        const styles = {
          opacity: "1",
          transform: `translate3d(${translateX}%,0,0)`,
          clipPath: getRandomRectanglePolygonCss({ minHeight: options.slice.minHeight, maxHeight: options.slice.maxHeight, minWidth: 1, maxWidth: 1 })
        };
        if (options.slice.hueRotate) {
          styles.filter = `hue-rotate(${Math.floor(getGlitchRandom(options, index / stepCount) * 360)}deg)`;
        }
        steps.push(styles);
      }
      return {
        steps,
        timing: Object.assign({ easing: `steps(${stepCount},jump-start)` }, options.timing)
      };
    };
    var generateGlitchPulseLayer = (options) => {
      return !options.pulse ? null : {
        steps: [
          { transform: "scale(1)", opacity: "1" },
          { transform: `scale(${options.pulse.scale})`, opacity: "0" }
        ],
        timing: Object.assign(Object.assign({}, options.timing), { delay: (options.glitchTimeSpan ? options.glitchTimeSpan.start : 0) * options.timing.duration, easing: "ease-in-out" })
      };
    };
    var generateBaseLayer = (options) => {
      if (!options.shake) {
        return { steps: [], timing: {} };
      }
      const stepCount = Math.floor(options.shake.velocity * options.timing.duration / 1e3) + 1;
      const steps = [];
      for (let index = 0; index < stepCount; ++index) {
        const translateX = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeX * 100;
        const translateY = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeY * 100;
        steps.push({
          transform: `translate3d(${translateX}%,${translateY}%,0)`
        });
      }
      return {
        steps,
        timing: Object.assign({ easing: `steps(${stepCount},jump-start)` }, options.timing)
      };
    };
    var generateLayers = (options) => [
      generateBaseLayer(options),
      generateGlitchPulseLayer(options),
      ...Array.from({ length: options.slice.count }).map(() => generateGlitchSliceLayer(options))
    ].filter((entry) => entry !== null);
    var mergeOptions = (...objects) => {
      const isObject = (obj) => obj && typeof obj === "object";
      return objects.reduce((prev, obj) => {
        Object.keys(obj).forEach((key) => {
          if (isObject(prev[key]) && isObject(obj[key])) {
            prev[key] = (0, exports.mergeOptions)(prev[key], obj[key]);
          } else if (obj[key] !== void 0) {
            prev[key] = obj[key];
          }
        });
        return prev;
      }, {});
    };
    exports.mergeOptions = mergeOptions;
    var prepareGlitchElement = (element, options) => {
      var _a, _b;
      if (!options.createContainers) {
        return {
          container: element,
          layersContainer: element,
          glitched: element.firstElementChild
        };
      }
      if (!element.dataset.glitched) {
        const layersContainer2 = document.createElement("div");
        const container2 = document.createElement("div");
        if (getComputedStyle(element).getPropertyValue("display").match(/^inline/)) {
          container2.style.display = "inline-block";
        }
        container2.appendChild(layersContainer2);
        (_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(container2, element);
        layersContainer2.prepend(element);
        return {
          container: container2,
          layersContainer: layersContainer2,
          glitched: element
        };
      }
      const layersContainer = element.parentElement;
      const container = (_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.parentElement;
      while (layersContainer.children.length > 1) {
        layersContainer.removeChild(layersContainer.children[1]);
      }
      layersContainer.firstElementChild.getAnimations().forEach((animation) => animation.cancel());
      return {
        container,
        layersContainer,
        glitched: element
      };
    };
    var glitchElement = (element, layers, options) => {
      const { glitched, container, layersContainer } = prepareGlitchElement(element, options);
      layersContainer.style.display = "grid";
      if (options.hideOverflow) {
        container.style.overflow = "hidden";
      }
      if (options.html) {
        glitched.innerHTML = options.html;
      }
      glitched.style.gridArea = "1/1/-1/-1";
      const baseLayer = glitched.cloneNode(true);
      baseLayer.style.gridArea = "1/1/-1/-1";
      baseLayer.style.userSelect = "none";
      baseLayer.style.pointerEvents = "none";
      baseLayer.style.opacity = "0";
      for (let i = 0; i < layers.length - 1; ++i) {
        const layerDiv = baseLayer.cloneNode(true);
        layersContainer.appendChild(layerDiv);
      }
      const startGlitch = () => {
        layers.forEach((layer, i) => {
          layersContainer.children[i].animate(layer.steps, layer.timing);
        });
      };
      const stopGlitch = () => {
        layers.forEach((_, i) => {
          layersContainer.children[i].getAnimations().forEach((animation) => {
            animation.cancel();
          });
        });
      };
      container.onmouseenter = null;
      container.onmouseleave = null;
      container.onclick = null;
      switch (options.playMode) {
        case "always":
          startGlitch();
          break;
        case "hover":
          container.onmouseenter = startGlitch;
          container.onmouseleave = stopGlitch;
          break;
        case "click":
          container.onclick = () => {
            stopGlitch();
            startGlitch();
          };
          break;
      }
      element.dataset.glitched = "1";
      return { container, startGlitch, stopGlitch };
    };
    var glitch = (elOrSelector = ".powerglitch", userOptions = {}) => {
      const options = (0, exports.mergeOptions)(getDefaultOptions(userOptions.playMode), userOptions);
      let elements = [];
      if (typeof elOrSelector === "string") {
        elements = Array.from(document.querySelectorAll(elOrSelector));
      } else if (elOrSelector instanceof NodeList) {
        elements = Array.from(elOrSelector);
      } else if (Array.isArray(elOrSelector)) {
        elements = elOrSelector;
      } else if (elOrSelector instanceof HTMLElement) {
        elements = [elOrSelector];
      }
      const layers = generateLayers(options);
      const entries = elements.map((element) => glitchElement(element, layers, options));
      return {
        containers: entries.map((entry) => entry.container),
        startGlitch: () => entries.forEach((entry) => entry.startGlitch()),
        stopGlitch: () => entries.forEach((entry) => entry.stopGlitch())
      };
    };
    exports.PowerGlitch = {
      glitch,
      generateLayers,
      getDefaultOptions
    };
  }
});
export default require_src();
//# sourceMappingURL=powerglitch.js.map
